package MapGen

import MapConstants
import HashSet

enum Dir
  North
  South
  West
  East

function Dir.toOffset() returns coord
  coord val
  switch this
    case North
      val = coord(0, 1)
    case South
      val = coord(0, -1)
    case West
      val = coord(-1, 0)
    case East 
      val = coord(1, 0)
  return val

function Dir.openDoor(MapRoom room)
  switch this
    case North
      room.isNorthOpen = true
    case South
      room.isSouthOpen = true
    case West
      room.isWestOpen = true
    case East
      room.isEastOpen = true

function Dir.opposite() returns Dir
  switch this
    case North
      return Dir.South
    case South
      return Dir.North
    case West
      return Dir.East
    case East
      return Dir.West

class RoomPair
  MapRoom fst 
  MapRoom scd
  
  construct(MapRoom fst, MapRoom scd)
    this.fst = fst
    this.scd = scd
    
  // returns direction from fst to second
  function getDir() returns Dir
    let xdiff = fst.point.x - scd.point.x
    let ydiff = fst.point.y - scd.point.y
    if xdiff.abs() > ydiff.abs()
      // more east west than north south
      if xdiff > 0
        return Dir.West
      else 
        return Dir.East
    else
      if ydiff > 0
        return Dir.South
      else 
        return Dir.North


class Door 
  MapRoom source 
  Dir dir

  construct(MapRoom source, Dir dir)
    this.source = source
    this.dir = dir
    
enum Status
  Unexplored
  Start
  Finish

function Status.toString() returns string
  string ret
  switch this
    case Unexplored
      ret = "Unexplored"
    case Start
      ret = "Start"
    case Finish
      ret = "Finish"
  return ret

enum CreepType
  None
  Standard
  Trap
  Miniboss

// A room in the map. Contains info for gen and doors and the like.
public class MapRoom
  Status status
  // The distance to the start of the map
  int distance = 0
  coord point

  // The
  bool isStart = false
  bool isFinish = false

  bool shop = false
  bool treasure = false
  // Is there a revive shrine in this room?
  bool shrine = false

  // Doors
  bool isNorthOpen = false
  bool isSouthOpen = false
  bool isEastOpen = false
  bool isWestOpen = false
  
  construct(coord point)
    this.point = point
    this.status = Status.Unexplored

  function toString() returns string
    return this.point.toString() + "@" + distance.toString() + "\n" +
        (isStart ? "START\n" : "") + (isFinish ? "FINISH\n" : "") + 
        status.toString() + "\n"

/** This class is used for generation. Represents a whole map of a given size. */
public class Map 
  // The width and height of this map
  coord size
  
  // Special locations within the map itself
  coord start
  coord finish

  MapRoom array[MAP_ROWS * MAP_COLS] rooms

  construct(coord size)
    this.size = size
    for y = 0 to size.y - 1
      for x = 0 to size.x - 1
        rooms[(size.x * y) + x] = new MapRoom(coord(x, y))
  
  function getRandomPoint() returns coord
    return coord(GetRandomInt(0, size.x - 1), GetRandomInt(0, size.y - 1))

  function getRoom(coord point) returns MapRoom
    return rooms[(size.x * point.y) + point.x]

  function isPointInMap(coord point) returns bool
    return 0 <= point.x and point.x < size.x and 0 <= point.y and point.y < size.y

function addValidDoor(Map map, MapRoom room, HashSet<Door> doors, Dir dir)
  let point = room.point + dir.toOffset()
  let inMap = map.isPointInMap(point)
  let isUnexplored = inMap ? map.getRoom(point).status == Status.Unexplored : false
  Log.debug("AddValidDoor of " + point.toString() + " | inMap: " + inMap.toString() + " | isUnexplored: " + isUnexplored.toString())
  if inMap and isUnexplored
    Log.debug("Valid door found")
    doors.add(new Door(room, dir))

function addAllValidDoors(Map map, MapRoom room, HashSet<Door> doors)
  Log.debug("Adding valid doors")
  addValidDoor(map, room, doors, Dir.North)
  addValidDoor(map, room, doors, Dir.South)
  addValidDoor(map, room, doors, Dir.East)
  addValidDoor(map, room, doors, Dir.West)

function buildDoorSet(Map map, HashSet<MapRoom> rooms) returns HashSet<Door>
  let doors = new HashSet<Door>()
  for room in rooms
    addAllValidDoors(map, room, doors)
  return doors

function openADoor(Map map, HashSet<MapRoom> rooms, HashSet<Door> doors, Status st)
  // if there are available spaces left
  if doors.size() > 0
    // pick a door from the set
    let door = doors.get(GetRandomInt(0, doors.size() - 1))
    // open the door
    // mark new room as explored.
    let room = map.getRoom(door.source.point + door.dir.toOffset())
    room.status = st
    room.distance = door.source.distance + 1
    rooms.add(room)
    door.dir.openDoor(door.source)
    door.dir.opposite().openDoor(room)
  else
    Log.debug("No doors to open")

/** Returns the total distance of two rooms if they are in different halves. */
function getRoomCombinedDitance(RoomPair pair) returns int
  var ret = -1
  if pair.fst.status != pair.scd.status
    // They're in different sets, return the distance.
    ret = pair.fst.distance + pair.scd.distance
  return ret

function testRoomPair(int bestDist, HashSet<RoomPair> pairs, RoomPair testPair) returns int
  let dist = getRoomCombinedDitance(testPair) 
  var retDist = bestDist
  // clear and reset
  if dist > bestDist
    retDist = dist
    for pair in pairs
      destroy pair
    pairs.clear()
  // add to the pairs
  if dist == retDist
    pairs.add(testPair)
  return retDist

public function generateMap(coord size) returns Map
  Log.debug("Generating map")
  let map = new Map(size)
  // pick a start
  map.start = map.getRandomPoint()
  map.getRoom(map.start).isStart = true
  map.getRoom(map.start).status = Status.Start
  // pick an end
  map.finish = map.start
  while map.finish == map.start
    map.finish = map.getRandomPoint()
  map.getRoom(map.finish).isFinish = true
  map.getRoom(map.finish).status = Status.Finish
  // create sets of rooms
  let startRooms = new HashSet<MapRoom>..add(map.getRoom(map.start))
  let finishRooms = new HashSet<MapRoom>..add(map.getRoom(map.finish))
  // create the sets of doors going to unexplored rooms
  var startDoors = buildDoorSet(map, startRooms)
  var finishDoors = buildDoorSet(map, finishRooms)
  // alternativng sets, do the following until no more rooms are unexplored.
  Status last = Status.Unexplored
  while startRooms.size() + finishRooms.size() < size.x * size.y
    last = last == Status.Start ? Status.Finish : Status.Start
    Log.debug("Opening: " + (last == Status.Start ? "Start" : "Finish") + " | " + 
      startRooms.size().toString() + "+" + finishRooms.size().toString() + "<" + 
      (size.x * size.y).toString())
    if last == Status.Start
      openADoor(map, startRooms, startDoors, last)
    else
      openADoor(map, finishRooms, finishDoors, last)
    // update set with new doors and remove any that exist
    startDoors = buildDoorSet(map, startRooms)
    // update other set to remove any doors going into this room.
    finishDoors = buildDoorSet(map, finishRooms)

  // compile pairs of adjacent rooms, one from each set, to find the greatest distance.
  Log.debug("Connecting halves")
  var bestDist = -1
  var pairs = new HashSet<RoomPair>()
  for y = 0 to size.y - 1
    for x = 0 to size.x - 1
      if y > 0 
        // down
        let testPair = new RoomPair(map.getRoom(coord(x, y)), map.getRoom(coord(x, y - 1)))
        bestDist = testRoomPair(bestDist, pairs, testPair)
      if x > 0 
        // left
        let testPair = new RoomPair(map.getRoom(coord(x, y)), map.getRoom(coord(x - 1, y)))
        bestDist = testRoomPair(bestDist, pairs, testPair)
  // Pairs now contains all equally greatest length pairs. Pick one randomly and open
  Log.debug("Found " + pairs.size().toString() + " pairs of rooms with distance " + bestDist.toString())
  let connection = pairs.get(GetRandomInt(0, pairs.size() -1))
  connection.getDir().openDoor(connection.fst)
  connection.getDir().opposite().openDoor(connection.scd)
  
  // OPTIONAL: reposition the finish to be farthest away from it's current location, in it's set, not on the start path.
  return map
  
